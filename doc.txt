Języki formalne i kompilatoryTranslator z podzioru języka Java do języka C
Autor: Piotr Skurski
1. Gramatyka  (skopiować plik z gramatyką bez lexera + ewentualne komentarze)
2. Zdefiniowane stałe słownikowe 
  a) Operatory 
    - dodawanie '+' 
    - odejmowanie '-' 
    - mnożenie '*' 
    - dzielenie '/' 
    - przypisania '=' 
    - średnik ';' 
    - przecinek rozdzielający parametry metody ',' 
    - logiczny, równości '==' 
    - logiczny, nierówności '!=' 
   b) Nawiasy 
    - otwierający '(' 
    - zamykający ')' 
    - otwierający dla klas, metod, bloków '{' 
    - zamykający dla klas, metod, bloków '}' 
    - otwierający dla tablic '[' 
    - zamykający dla tablic ']' 
   c) Instrukcje 
    - 'if' 
    - 'else' 
    - 'return' 
   d) Modyfikatory 
    - 'public' 
    - 'private' 
    - 'protected' 
    - 'static final' 
    - 'final static' 
    - 'abstract'
3. Przykład (wkleić plik wejściowy z kodem Java)

4. Opis typizacji tłumaczonego języka W stworzonym translatorze dostępne są: 
  a) znaki zdefiniowane w stałych słownikowych 
  b) typy prymitywne z języka Java a więc liczby całkowite i zmiennoprzecinkowe: (char, short, int, long, float, double) oraz void 
  c) zmienne - mogą zawierać duże i małe litery i muszą zaczynać się od litery, cyfry i kropki

5. Uzasadnienie wyboru generatora parserów Wybrałem generator parserów ANTLR (wersja 4) dlatego że jest zaimplementowany w języku Java, 
posiada interfejs w języku Java oraz jest dobrze udokumentowany w internecie. Jak również jest 
stosunkowo prosty w użyciu, wymaga jedynie napisanie gramatyki a na jej podstawie narzędzie już samo 
generuje potrzebne klasy (parser, lexer, visitor, listener). 

6. Opis napotkanych problemów 
  a) Wybór wzorca - sposobu przejścia przez drzewo - Listener albo Visitor. Obydwa udostępniają 
podobną funkcjonalność ale Visitor jest bardziej czytelny i generyczny. Listener wymaga tworzenia 
dodatkowych pól w klasie które by przetrzymywały dane zbierane podczas przechodzenia przez drzewo a 
później pobierania tych danych przez gettery. Visitor bezpośrednio zwraca interesujące nas dane, 
wymuszając również konieczność stworzenia własnego modelu dla poszczególnych danych.
  b) Rozpoznanie konkretnej reguły z gramatyki - np. w deklaracji "expression" mamy kilka 
reguł, skąd będziemy wiedzieć która reguła została zastosowana, jednym z rozwiązań jest sprawdzanie 
jaka operacja wystąpiła (np. + / - ) co wiąże się ze stosowaniem instrukcji warunkowych, prostszym i 
bardziej czytelnym rozwiązaniem dla mnie było zastosowanie etykiet. Do każdej reguły w "expression" 
dołączona jest etykieta dzięki temu parser tworzy osobną metodę dla każdej reguły a więc każdej 
regule odpowiada dokładnie jedna metoda w klasie ExpressionVisitor. To czyni kod bardziej zrozumiałym 
i czytelnym, łatwiejszym w debugowaniu i wprowadzaniu zmian.
  c) Jak sobie poradzić w przypadku instrukcji zagnieżdzonych wielokrotnie - np. w deklaracji 
"statement" mamy reguły w których występuje "expression" oraz kolejne "statement". Z pomocą przyszedł 
wzorzec Visitor, przy przetwarzaniu konkretnej metody możemy dla instrukcji zagnieżdzonej wywołać 
rekursywnie tą samą klasę (StatementVisitor), która sama rozpozna jaka reguła jest zastosowana w 
instrukcji zagnieżdzonej. Natomiast w modelu, w klasie Statement zastosowałem wzorzec Kompozyt a więc 
obiekt statement może być obiektem prostym jak i zawierać w sobie kolekcję obiektów statement.
  d) Gdzie dokonać translacji? Visitor pozwala nam przemierzyć całe drzewo ale w którym miejscu 
dokonać translacji. Ja stworzyłem modele dla interesujących mnie danych i te modele przechowują dane 
oraz implementują interfejs Printer z metodą print() w której następuje translacja z Javy na C. Klasa 
która wywołuje translację to klasa Output.


Link do repozytorium:
https://github.com/skurski/antlr-java2c-translator

Bibliografia
"The Definitive ANTLR 4 Reference" Terence Parr
http://jakubdziworski.github.io/java/2016/04/01/antlr_visitor_vs_listener.html
https://stackoverflow.com/questions/29971097/how-to-create-ast-with-antlr4
